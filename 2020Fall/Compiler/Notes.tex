\documentclass[]{report}
\usepackage[hmargin=1.25in,vmargin=1in]{geometry} %调整页边距
% \usepackage[inner=1in,outer=1.25in]{geometry} %书籍左右不等宽排版
\usepackage[utf8]{inputenc}
\usepackage[]{ctex} %据说可以直接调用诸如 \kaishu \fangsong \heiti 的命令修改字体
\usepackage[svgnames]{xcolor} % Using colors
% \usepackage{background} % To include background images
\usepackage{fancyhdr} % Needed to define custom headers/footers
\usepackage[]{xeCJK}
\setCJKmainfont[BoldFont = STHeiti, ItalicFont = STKaiti]{Songti SC Light} %中文主字体
\setCJKsansfont[BoldFont = Weibei SC, ItalicFont = HanziPen SC]{Xingkai SC Light} %中文无衬线字体
\setCJKmonofont[BoldFont = Libian SC, ItalicFont = STFangsong]{Yuanti SC Light} %中文等宽字体
\setmainfont{Times New Roman} %\rmfamily
\setsansfont[ItalicFont = American Typewriter]{Comic Sans MS} %\sffamily
\setmonofont{Courier} %\ttfamily
\newfontfamily\monaco{Courier} % 用于代码段字体设置
\usepackage{titlesec}
\titleformat{\chapter}{\centering\huge\bfseries}{第~\thechapter~章}{1em}{}
\titleformat{\section}{\Large\bfseries}{第~\thesection~节}{1em}{}
\usepackage{lipsum} %填充文本

\newcommand{\myCoral}{\color[HTML]{FF7F50}} %设置为珊瑚色

\usepackage{ulem} %解决下划线、删除线之类的
\usepackage{listings}
\lstset{
language=C++,
numberstyle = \monaco,
basicstyle = \monaco,
keywordstyle = \color{blue}\bfseries,
commentstyle=\color[HTML]{006400},
tabsize = 4,
%backgroundcolor=\color{bg}
emph = {int,float,double,char},emphstyle=\color{cyan},
emph = {[2]const, typedef},emphstyle = {[2]\color{red}} }

\makeatletter
\newif\if@restonecol
\makeatother
\let\algorithm\relax
\let\endalgorithm\relax
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}%[ruled,vlined]{
\usepackage{algpseudocode}
\usepackage{amsmath}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}  % Use Input in the format of Algorithm
\renewcommand{\algorithmicensure}{\textbf{Output:}} % Use Output in the format of Algorithm

\usepackage{amsmath} %数学公式问题
\usepackage{amsthm} %公式环境，如proof
\usepackage{booktabs} %三线表
\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}} %解决单元格内部换行的问题
% 比如这个 Beijing & 0,5 & 1,6 & 2,7 & 3,8 & 4,9 & The number changes every 3 months \\
% 改成这个 \tabincell{l}{Beijing}& \tabincell{c}{0,5}& \tabincell{c}{1,6}& \tabincell{c}{2,7}& \tabincell{c}{3,8}& \tabincell{c}{4,9}& \tabincell{c}{The number changes \\ every 3 months} \\
% 一个单元格过长，整行都需要修改
% 可以配合 \resizebox*{h-width}{v-width}{contents, e.g.tabular} 使用

\usepackage{mathrsfs} %在公式里面使用那个最花的字体
\usepackage{amssymb} %公式里面用空心黑体和旧式字体
\usepackage{amssymb} %AMS符号
\usepackage{amsthm} %AMS定理环境

\usepackage{markdown} %使用markdown语法，在编译时需要打开 shell-escape 标记，即 $ xelatex --shell-escape example.tex
\markdownSetup{hashEnumerators = true} %允许使用 #. 的方式编写有序列表
\markdownSetup{inlineFootnotes = true} %允许使用脚注形式的超链接，调用语法为 [anchor](uri), ^[footnote], <uri>
\markdownSetup{fencedCode = true} %以反引号和缩进来插入代码段，相当于 verbatim
\markdownSetup{
  pipeTables = true
} %支持表格的用法 (图片已经在markdown包里面支持了)
% \usepackage{booktabs} %解决三线表的线条粗细问题

\usepackage{graphicx} %插入图片
\usepackage{pdfpages} %插入PDF文件
\usepackage{makeidx}

\usepackage{tikz} %带圈字符
\usepackage{etoolbox} %带圈字符 (提供robustify)
\usepackage{enumitem}
\newcommand*{\circled}[1]{\lower.7ex\hbox{\tikz\draw (0pt, 0pt)%
    circle (.5em) node {\makebox[1em][c]{\small #1}};}} %新定义命令：带圈字符
\robustify{\circled}
% \usepackage{enumerate} %有序列表

\usepackage{hyperref} %超链接
% \usepackage[hidelinks]{hyperref} %隐藏超链接的红框
\markdownSetup{
  inlineFootnotes = true,
  renderers = {
    link = {\href{#3}{#1}},
  }
} % markdown块中使用直接点进去的超链接
% \setlist[enumerate,1]{label=(\arabic*).,font=\textup,leftmargin=7mm,labelsep=1.5mm,topsep=0mm,itemsep=-0.8mm}
% \setlist[enumerate,2]{label=(\alph*).,font=\textup,leftmargin=7mm,labelsep=1.5mm,topsep=-0.8mm,itemsep=-0.8mm}

\usepackage{braket}

%%%%%% Setting up the style

% \setlength\parindent{0pt} % Gets rid of all indentation
% \backgroundsetup{contents={\includegraphics[width=\textwidth]{ustc-name.pdf}},scale=0.4,placement=top,opacity=0.6,color=cyan,vshift=-20pt} %  USTC Logo

\pagestyle{fancy} % Enables the custom headers/footers

% 使用默认的Chapter页眉
% \lhead{} \rhead{} % Headers - all  empty

% \title{\vspace{-1.8cm}  \color{DarkRed} Laboratory Rotation Report}
% \subtitle{Title of the proposal % Title of the rotation project
% \vspace{-2cm} }
% \date{\today} % No date

\lfoot{\color{Grey} \textit{上官凝}}  % Write your name here
\rfoot{ \color{Grey} 编译原理 }
\cfoot{\color{Grey} \thepage}

\renewcommand{\headrulewidth}{0.0pt} % No header rule
\renewcommand{\footrulewidth}{0.4pt} % Thin footer rule

\title{{\huge {编译原理笔记}}}
\author{上官凝}
\date{\today}

\linespread{1.3} %行间距为1.3倍默认间距 (1.3 x 1.2倍字符宽度)

\makeindex

\begin{document}
\theoremstyle{definition} \newtheorem{theorem}{Thm}[section] %定义一个定理Thm，序号为section的下一级序号
\theoremstyle{definition} \newtheorem{definition}{Def}[section] %定义一个定义Def，序号为section的下一级序号
\theoremstyle{plain} \newtheorem{lemma}{lemma}[section] %引理

	\maketitle
	\newpage

	\tableofcontents
	\newpage

	\chapter{词法分析}
	\begin{figure}
		\centering
		\begin{minipage}{40em}
			\centering
			\includegraphics[scale = 0.3]{images/lecture_intro.pdf}
			\caption{编译器总览}
		\end{minipage}
	\end{figure}
	词法分析器的任务是把构成源程序的字符流翻译成词法记号流。其目的是将输入字符串识别为有意义的子串
	\begin{enumerate}
		\item 子串的种类(Name)
		\item 可帮助解释和理解该子串的属性(Attribute)
		\item 可描述具有相同特征的子串的模式(Pattern)
	\end{enumerate}
	\section{词法记号及属性、描述和识别}
		\subsection{词法记号和属性}
		词法记号由记号名和可选的属性值构成的二元组，经常使用记号名来引用记号。一个记号的模式描述属于该记号的词法单元的形式。词法单元是源程序中匹配一个记号模式的字符序列，它由词法分析器识别为该记号的一个实例。\textit{为什么需要属性？}概括的说，记号名影响语法分析的决策，属性影响记号的翻译。
		\subsection{串和语言}
		语言表示字母表上的一个串集，属于该语言的串称为该语言的句子或字，注意$\varnothing$和$\{\varepsilon\}$这样的抽象语言也符合这个定义。其运算参考字符串的运算（连接）和集合的运算（交并补etc）
		\subsection{正则表达式}
		约定：
		\begin{enumerate}
			\item 闭包运算（$^*$）有最高的优先级并且是左结合的运算
			\item 连接运算（两个正规式并列）的优先级次之且也是左结合的运算
			\item 选择运算（$\mid$）的优先级最低并且也是左结合的运算
			\item 零个或一个实例（$r?$）表示 $r\mid\varepsilon$
			\item 字符组（$[abc]$）表示$a\mid b\mid c$
			\item 缩写字符组（$[a-z]$）表示$a\mid b\mid\cdots\mid z$
		\end{enumerate}\par
		可以对正规式命名，并用这些名字来引用相应的正规式。可以采用自底向上的方式来构建正规定义
		\subsection{状态转换图}
		（打个广告：在我的\href{http://home.ustc.edu.cn/~astark/}{主页}上面放了一个在线画FSM的网址连接）\par
		大概长这样（这个是分析各种运算符以及注释的一个转换图，数字识别没有画完整）（IN是指intermediate，中间态）：\par
		\begin{figure}[h!]
			\centering
			\begin{minipage}{40em}
				\centering
				\includegraphics[scale = 0.35]{images/FSM_Sample.png}
			\end{minipage}
		\end{figure}\par
		在词法分析时，会出现“移进归约冲突”（这里不是这么叫的，我只是借鉴一下这种说法）。就是识别到一个token，它可能是一个关键字，也有可能是其他token的前缀。这时候应用最长匹配规则，即lookahead，如果不符合词法规则（状态机无法跳转）就回退。\par
		值得注意的是，词法分析器对程序采取非常局部的观点，即词法分析器只会管给定的程序（一个字符串）是不是能拆分成符合词法定义的token流。这些token在词法分析器看来是相互无关的。
		\subsection{关于FLEX的正则表达式}
		众所周知，实验会用到FLEX，在写\verb|.l|文件的时候要写正则表达式，大概规则如下：
		\begin{enumerate}
			\item \verb|.| 匹配任何单个字符，除 \verb|\n|.
			\item \verb|-| 表示匹配范围，如：\verb|a-z|，表示匹配a-z之间的任何字符
			\item \verb|*| 匹配前面表达式的零个或多个拷贝。
			\item \verb|[]| 匹配括号内的任意字符的字符类，第一个符号是 \verb|^|，表示匹配除括号中的字符以外的任意字符，如 \verb|[^/]| 表示除斜杠以外的所有字符。
			\item \verb|()| 表示里面的模式被允许匹配多少次。
			\item \verb|\| 用于转义字符
			\item \verb|+| 匹配前面表达式一次或多次出现。
			\item \verb|?| 匹配前面表达式零次或1次出现。
			\item \verb||| 匹配前面表达式或随后表达式
			\item \verb|""| 引号中的每个字符解释为字面意思
			\item \verb|{}| 指示一个模式可能出现的次数，后面可以跟 \verb|*| 或者 \verb|+|
		\end{enumerate}\par
		以及，可以\textbf{参考}\href{https://blog.csdn.net/u014594922/article/details/51224231}{这个}文章
	\section{有限自动机}
		\subsection{NFA和DFA}
		NFA（不确定的有限自动机）可以把同样的符号标记在出自同一个状态的多条边上，而DFA（确定的有限自动机）是NFA的特殊情况，其中：任何状态下都没有$\varepsilon$转换；且对任何状态s和任何输入符号a，最多只能有一条表示为a的边离开s
		\subsection{正则表达式到NFA}
		基本模型有$a\mid b$、$ab$、$s^*$和$(s)$，分别对应以下的图：
		\begin{figure}[h!]
			\centering
			\begin{minipage}{40em}
				\begin{minipage}{18em}
					\centering
					\includegraphics[scale = 0.18]{images/s_mid_t.png}
				\end{minipage}
				\begin{minipage}{18em}
					\centering
					\includegraphics[scale = 0.23]{images/st.png}
				\end{minipage}
			\end{minipage}
		\end{figure}
		\begin{figure}[ht!]
			\centering
			\begin{minipage}{30em}
				\centering
				\includegraphics[scale = 0.25]{images/s_star.png}
			\end{minipage}
		\end{figure}
		\subsection{NFA到DFA}
		NFA的状态是DFA的状态集合（闭包）。主要的有两步：
		\begin{enumerate}
			\item 递归计算出来包含状态0（start状态）的闭包（就是经过$\varepsilon$能到达的所有状态）
			\item 这个闭包在接收某个输入之后可能到达的新的状态闭包
		\end{enumerate}\par
		然后对新的闭包迭代第二步，直到没有新的了
		\subsection{DFA的化简}
		观察DFA的状态转换表，将对于任意输入符号，其跳转都一样的几个状态合并为同一状态，并选取一个代表。首先要\textbf{分开接受状态和非接受状态}


	\chapter{语法分析}
	\textit{输入：词法分析获得的记号序列；输出：程序的语法树}。需要一种可以描述合法记号序列的语言、一种可以区分合法和非法的记号序列的方法。正则表达式不能用于描述配对或嵌套的结构，这是因为有限自动机不能记录重复访问同一状态的次数。\par
	\section{上下文无关文法}
		上下文无关文法CFG是由一个四元组$(V_T,V_N,S,P)$组成的：
		\begin{enumerate}
			\item 终结符：就是“句型”最终需要化成的形式，里面的元素都是确定的符号，也称为$token$。\textit{在谈论编程语言的文法时，记号名时终结符的同义词。}
			\item 非终结符：可以认为是推导过程中的“中间变量”，或“形式参量”，用自下而上的角度来说，非终结符是终结符或/和非终结符的规约
			\item 开始符号：是语法树的$root$
			\item 产生式的有限集合：生成规则，用$\to$
		\end{enumerate}
		\subsection{CFG推导}
		CFG推导是“从文法推出文法所描述的语言中所包含的合法串集合的动作”，也就是说，从开始符号开始，利用生成规则进行迭代替换，得到句型。“上下文无关”是指在推导过程中，每一步$\alpha A\beta\Rightarrow\alpha\gamma\beta$仅依赖于$A\to\gamma$，而与$\alpha,\beta$无关。对于语言、文法、句型、句子，语言是句子的集合，句子是实例。最左推导$\Rightarrow_{lm}$和最右推导（规范推导）$\Rightarrow_{rm}$。一步推导$\Rightarrow$和零步或多步推导$\Rightarrow^*$以及一步或多步推导$\Rightarrow^+$。\par
		\subsection{文法的二义性}
		文法的某些句子存在不止一种最左（最右）推导，或者不止一棵分析树，则该文法是二义的。一般是由优先级和结合性的不确定导致的。所以可以通过定义优先级（将多个选项拆分为不同非终结符的嵌套推导规则来认为定义等级划分）来解决这个问题。这样，更接近于开始符号的非终结符就不能直接推导到终结符，更接近于终结符的不能从开始符号终结推导。\textit{左推导优先级从高到低，右推导相反}比如将第一个式子换成下面的几个：
		\[\begin{gathered}
			E\to E+E\mid E*E\mid(E)\mid\mathbf{id}\\
			E\to E+E\mid F\\
			F\to F*F\mid G\\
			G\to (G)\mid\mathbf{id}
		\end{gathered}\]
		\subsection{悬空else文法}
		悬空else文法是一个经典的例子：
		\begin{figure}[h!]
			\centering
			\begin{minipage}{20em}
				\centering
				\includegraphics[scale = 0.2]{images/Impending_ELSE.pdf}
				\caption{悬空else文法及其二义性}
			\end{minipage}\quad
			\begin{minipage}{20em}
				\centering
				\includegraphics[scale = 0.2]{images/Eliminate_Ambiguity_of_ELSE.pdf}
				\caption{悬空else文法二义性的消除}
			\end{minipage}
		\end{figure}\par
		应当注意的是，文法的二义性并不意味着语言是二义的。只有当产生一个语言的所有文法都是二义的时，才称为是二义的。而且也可以构造允许二义文法的分析器，但要附带消除二义性但规则（剪枝回溯）。值得看到的是，定义无二义文法可能会失去简洁性。
		\subsection{左递归}
		一个文法是左递归的，如果他有非终结符A，对于某个串$\alpha$，存在推导$A\Rightarrow^+A\alpha$。自上而下的分析方法不能用于左递归文法。
	\section{自顶向下分析方法}
		\subsection{递归下降分析方法}\label{subsection:Recursive_Descent}
		包括一个输入缓冲区和向前看指针lookahead，自左向右扫描输入串；设计一个辅助过程match()，将lookahead指向的位置与产生式迭代生成的终结符进行匹配，如匹配，将lookahead挪到下一个位置。就是对于一个可能的串，从root开始构建一棵语法的生成树。递归下降也有着自己的一些问题，比如可能进入无限循环。下面是递归下降的三个问题，
		\subsection{消除左递归}\label{subsection:Eliminating_Left_Recursion}
		左递归分为直接左递归和间接左递归。直接左递归有形如$A\rightarrow A\alpha$的产生式，间接左递归是通过有限次迭代（类似于证明序列）得到（非直接左递归首先变成直接左递归，然后消除他）。消除左递归的通用方法如下所示：首先将A的产生式组合在一起：
		\[A\to A\alpha_1\mid A\alpha_2\mid\cdots\mid A\alpha_m\mid\beta_1\mid\beta_2\mid\cdots\mid\beta_n\]
		其中$\beta_i$都不以A开始，$\alpha_i$非空，然后用
		\[\begin{gathered}
			A\to\beta_1A'\mid\beta_2A'\mid\cdots\mid\beta_nA'\\
			A'\to\alpha_1A'\mid\alpha_2A'\mid\cdots\mid\alpha_mA'\mid\varepsilon
		\end{gathered}\]
		代替A的产生式。注意后面加上了一个$\varepsilon$，作为一个终结符结束递归
		\subsection{有左因子的文法}
		有左因子的(left-factored)文法形如$A\to\alpha\beta_1\mid\alpha\beta_2$。在自上而下的分析中，当不清楚应该用非终结符$A$的那个选择来替换它时，可以通过重写$A$产生式来推迟这种决定，推迟到看到足够多的输入，能帮助正确决定所需选择为止。如上式等价于\[\begin{gathered}
			A\to\alpha A'\\
			A\to\beta_1\mid\beta_2
		\end{gathered}\]
		需要注意的是，提取左因子的重写并不能解决二义性，比如之前提到的悬空else文法，提取左因子之后成为
		\[\begin{gathered}
			stmt\to\mathbf{if}\ expr\ \mathbf{then}\ stmt\ optional_else_part\mid\mathbf{other}\\
			optional_else_part\to\mathbf{else}\ stmt\mid\varepsilon
		\end{gathered}\]
		这个文法对于如$\mathbf{if}\ expr\ \mathbf{then}\ \mathbf{if}\ expr\ \mathbf{then}\ stmt\ \mathbf{else}\ stmt$这个表达式时，有如下两种最左推导的分析树
		\begin{figure}[h!]
			\centering
			\begin{minipage}{20em}
				\centering
				\includegraphics[scale = 0.05]{images/Left_Ambiguity_1.JPG}
			\end{minipage}
			\begin{minipage}{20em}
				\centering
				\includegraphics[scale = 0.048]{images/Left_Ambiguity_2.JPG}
			\end{minipage}
		\end{figure}
		\subsection{复杂的回溯代价太高}
		非终结符有可能有多个产生式，由于信息缺失，无法准确预测选择哪一个，考虑到往往需要对多个非终结符进行推导展开，因此尝试的路径可能呈指数级爆炸
	\section{预测分析法}
		Predictive Parsing与递归下降法类似，但是没有若干尝试，没有回溯，采用的通过向前看一些记号来预测需要用到的产生式的方法。此方法接收LL(k)文法，即自左向右读取(left-to-right)，最左推导(leftmost derivation)，基于对k个记号向前看的推导。在实际应用中，LL(1)用的最广泛。
		\subsection{“第一个”集合和“跟随”集合}
		LL(1)文法中有两个最重要的集合，即FIRST($\alpha$)和FOLLOW($\alpha$)。
		\[FIRST(\alpha)=\{a\mid\alpha\Rightarrow^*a\dots\}\quad\alpha\in V_N,a\in V_T\]
		即，可以从$\alpha$推导出的句型的首部词的集合
		\[FOLLOW(A)=\{a\mid S\Rightarrow^*\dots Aa\dots\}\quad\alpha\in V_N,a\in V_T\]
		即，可能在推导过程中紧跟在A右边的终结符号的集合
		\begin{figure}[h!]
			\centering
			\begin{minipage}{20em}
				\centering
				\includegraphics[scale = 0.2]{images/LL1_first.pdf}
				\caption{确定给定推导文法的FIRST集合}
			\end{minipage}
			\begin{minipage}{20em}
				\centering
				\includegraphics[scale = 0.2]{images/LL1_follow.pdf}
				\caption{确定给定推导文法的FOLLOW集合}
			\end{minipage}
		\end{figure}
		\subsection{LL(1)文法}
		则有LL(1)文法的定义为：对于任何两个产生式$A\to\alpha\mid\beta$都有
		\begin{enumerate}
			\item $FIRST(\alpha)\cap FIRST(\beta)=\varnothing$
			\item 若$\beta\Rightarrow^*\varepsilon$，那么$FOLLOW(A)\cap FIRST(\alpha)=\varnothing$
		\end{enumerate}
		对于第二条，假设$FIRST(A)\cap FIRST(\alpha)=\{a\}$，即
		\[\begin{gathered}
			S\Rightarrow^*\dots Aa\dots\\
			A\Rightarrow^*a\alpha'
		\end{gathered}\]
		又由于$\beta\Rightarrow^*\varepsilon$所以当遇到$Aa$时，既可以用$A\to\alpha$来展开，也可以用$A\to\beta,\beta\Rightarrow^*\varepsilon$来消去A。\par
		LL(1)文法有一些明显的性质，如没有公共左因子（提取左因子）、不是二义的（规则重写）、不含左递归（化为直接左递归，拆分）
	\section{递归下降的预测分析}\label{section:Recursive_Descent_Function}
	所谓预测分析是指能根据当前的输入符号为非终结符确定采用哪一个选择（预读取k个token）。在这一个部分，主要是要求写出一个预测分析的程序伪代码。伪代码主要是包括两个部分，即$match$函数和对于每一个非终结符的函数。以如下的文法为例：
	\[\begin{gathered}
		type\to simple\mid\uparrow\mathbf{id}\mid\mathbf{array}\ [simple]\ \mathbf{of}\ type\\
		simple\to\mathbf{integer}\mid\mathbf{char}\mid\mathbf{num\ dotdot\ num}
	\end{gathered}\]
	其递归下降预测分析器（伪代码）为（部分）：
	\begin{lstlisting}
void match(terminal t)
{
	if (lookahead == t) lookahead = nextToken();
	else error();
}

void type()
{
	if ((lookahead == integer) || (lookahead == char)
		|| (lookahead == num))
		simple();
	else if (lookahead == '\uparrow')
	{
		match ('\uparrow');
		match (id);
	}
	else if (lookahead == array)
	{
		/* code */
	}
	else error();
}
	\end{lstlisting}
	具体来说，就是每一个非终结符$T$，需要构造过程$void T()$，在其中对$T$的产生式右端$\alpha$进行匹配。在匹配的判断中使用$FIRST$集合。匹配之后执行的动作为：非终结符调用他自己的过程，终结符$a$调用$match(a)$
		\subsection{预测分析表}
		对文法的每一个产生式$A\to\alpha$，执行以下两个步骤：
		\begin{enumerate}
			\item 对$FIRST(\alpha)$的每个终结符$A$，把$A\to\alpha$ 加入$M[A, a]$，注意这里的$\alpha$是一个表达式
			\item 对产生式$A\to\alpha$，考虑$FIRST(\alpha)$和$FOLLOW(A)$，如果$\varepsilon$在$FIRST(\alpha)$中，对$FOLLOW(A)$的每个终结符$b$（包括$\$$）, 把$A\to\alpha$加入$M[A, b]$
		\end{enumerate}
		值得注意的是，填入表格的$A\to\alpha$是一条推导文法，如$E\to TE'$或者$T'\to\varepsilon$
		注：多重定义条目意味着文法左递归或者是二义的，但是可以通过删除部分条目来消除
	\section{自底向上分析方法}
		\textbf{自左向右读取！}基本方法是归约（右推导的逆过程），用到句柄（可归约串，可能不唯一）的概念，思路是针对输入串，尝试根据产生式规则归约(reduce)到文法的开始符号，是一个比自顶向下更一般化的方法。归约是每一步，特定子串被替换为相匹配的某个产生式左部的非终结符。\par
		对于句柄，句柄是“该句型中和某产生式右部匹配的子串，并且把它归约成该产生式左部的非终结符，代表了最右推导的逆过程的一步”。首先句柄是字串而不一定是一个完整的串，它是在归约过程中某一步产生的句型中的一部分。从另一个方向来看，句柄是对应者自顶向下推导的过程中分析树的非树叶的结点。句柄的右边\textbf{仅包含终结符}（这是因为归约是最右推导的逆过程）。这里“句柄的右边”指的是在这一步规约的句型中，位置在此句柄右边的串。如果文法二义，那么句柄可能不唯一。\par
		比如说，在如下的最右推导（逆过程就是归约）中：
		\[\begin{gathered}
			S\to aABe\\
			A\to Abc\mid b\\
			B\to d\\
			S\Rightarrow_{rm}aABe\Rightarrow_{rm}aAde\Rightarrow_{rm}aAbcde\Rightarrow_{rm}abbcde
		\end{gathered}\]\par
		在句型$aAbcde$中，这一步用于规约的句柄为$Abc$，即“句型中的字串”，同时为产生式$A\to Abc$的右部匹配。
		\subsection{移进(shift)-归约(reduce)分析技术}
		\begin{enumerate}
			\item 两个空间：栈（用来保存已经扫描过的文法符号）、缓冲区（用来保存还未分析的文法符号）
			\item 四个状态：移进（shift，将下一个输入符号放到栈顶，以形成句柄）、归约（reduce，句柄替换为对应的产生式的左部非终结符）、接收（accept，分析成功）、报错（error）
		\end{enumerate}
		移进-归约技术需要解决一些问题，如：
		\begin{enumerate}
			\item 移进-归约冲突（如何决策选择移进(构造句柄)还是归约）
			\item 进行归约时，确定右句型中将要归约的子串(识别句柄)
			\item 归约-归约冲突（进行归约时，如何确定选择哪一个产生式）
		\end{enumerate}
	\section{LR(k)分析技术}
	【回顾】自顶向下和自底向上：\par
	\begin{enumerate}
		\item 自顶向下(Top-down)
		\begin{enumerate}
			\item 针对输入串，从文法的开始符号出发，尝试根据产生式规则推导(derive)出该输入串。
			\item LL(1)文法及非递归预测分析方法
			\item left-to-right scan + leftmost derivation
		\end{enumerate}
		\item 自底向上(Bottom-up)
		\begin{enumerate}
			\item 针对输入串，尝试根据产生式规则归约(reduce)到文法的开始符号。
			\item LR(k)文法及其分析器
			\item left-to-right scan + rightmost derivation
		\end{enumerate}
	\end{enumerate}\par
	一个文法，如果能为他构造出所有条目都唯一都LR分析表，就说他是LR文法。Say，LR语法分析器的关键在于构造LR分析表：\begin{enumerate}
		\item 计算所有可能的状态
		\begin{enumerate}
			\item 每一个状态描述了语法分析过程中所处的位置
			\item 可确定正在分析的产生式集合
			\item 可确定句柄形成的中间步骤
		\end{enumerate}
		\item 明确状态之前的跳转关系
		\item 明确状态与输入之间对应的移进或者归约操作
	\end{enumerate}\par
	LR分析器的格局是二元组，其第一个成分是栈的内容，第二个成分是尚未扫描的输入。活前缀是最右句型的前缀，该前缀不超过最右\textit{句柄}的右端。分析表的转移函数实际上是识别活前缀的DFA，规约函数是对句柄
	\section{SLR}
	文法G的LR(0)项目（简称项目）是在其右部的某个地方加点，表示分析过程的状态的产生式。点的左边是已经看见（读入）的部分，右边是期待看见的部分。或者说，左边是历史信息，右边是展望信息。\par
		\subsection{产生规则} 为了构造出指定文法的SLR分析表，首先重写此文法：
		\begin{enumerate}[label = \circled{\arabic{*}}]
			\item 增加一个新的开始符号（产生拓广文法），即如果之前文法G的开始符号是S，那么增加开始符号$S'$和产生式$S'\to S$，新增产生式的目的是用来指示分析器什么时候应该停止分析并宣布接收输入
			\item 将多路选择的产生式拆分开，比如$E\to E+T\mid T$拆分成$E\to E+T$和$E\to T$两个产生式，这样对判断状态集有好处
			\item 将所有的产生式编号，从$S'\to S\quad(0)$开始
		\end{enumerate}
		然后从新的开始产生式开始，用下面两条规则构造项目集的闭包：（和书上写的不一样）
		\begin{enumerate}
			\item 由上一个状态转换过来的产生式（点向后移动一个位置）
			\item 如果某一条产生式的点在一个非终结符前面，那么看这个非终结符的所有产生式，并将其初始产生式假如到闭包中
		\end{enumerate}
		解释一下上面的规则：
		\begin{enumerate}[label = \circled{\arabic{*}}]
			\item 我自己定义一个概念叫\textit{初始产生式}，意思是点加在产生式右部的最左端。（其实就是书上P76写的非核心项目加上$S'\to\cdot S$，如产生式$E\to E+T$，其初始产生式就是$E\to\cdot\, E+T$
			\item 在生成状态$I_0$时，从拓展文法的开始产生式$S'\to S$的初始产生式$S'\to \cdot S$开始
			\item 状态之间的跳转并不需要对前状态的所有元素（产生式）都满足，只表达一种对于此项目集\textbf{可能的}跳转模式
			\item 跳转状态，意味着接收了某种输入
			\item 点在不同位置的同一产生式视作两个不同的项目，需要单独加进去。比如本来我有一个产生式$E\to TE$，现在在闭包里面有$E\to T\cdot E$，我还要加进去$E\to \cdot TE$
		\end{enumerate}
		\subsection{有效项目}
		如果说$S'\Rightarrow^*\alpha Aw\Rightarrow\alpha\beta_1\beta_2 w$，那么就说项目$A\to\beta_1\beta_2$对活前缀$\alpha\beta_1$是有效的。一个项目对于好几个活前缀都可以是有效的，比如若$\beta_2\neq\varepsilon$则应当移进（继续读取才能规约为$A$）；若$\beta_2=\varepsilon$，则已经可以直接归约了。
		\subsection{SLR分析表}
		SLR分析表分为左右两部分，左边是动作(action)表，右边是转移(goto)表。二者的行标分别为终结符加$\$$和非终结符，列标为项目集（状态）。action表分为三种情况：
		\begin{enumerate}
			\item 对于没有读取完的产生式项目（点在右部中间，形如$A\to\alpha\cdot a\beta$，$a$为终结符，$\alpha,\beta$可以为$\varepsilon$），设这个项目所在的状态为$I_i$，读取$a$之后会跳转到$I_j$，即$I_i\stackrel{a}{\to}I_j$，那么就在分析表的第i行第a列填入$s_j$
			\item 对于读取完毕的产生式项目，设这个项目所在的状态为$I_i$，产生式的编号为$j$，那么就在分析表的第i行第a列填入$r_j$，其中a是FOLLOW(A)中的所有元素
			\item 对于包含项目$S'\to S\cdot$的状态$i$，在第i行第$\$$列填入$acc$
		\end{enumerate}
		转移表就是说如果状态i在接收非终结符A之后转移到状态j，那么就在第i行第A列填入j
		\subsection{SLR(1)文法}
		一个上下文无关文法G，通过上述算法构造出SLR语法分析表，且表项中没有移进/归约或 者归约/归约冲突，那么G就是SLR(1)文法。1代表了当看到某个产生式右部时，只需要再向前看1个符号就可决定是否用该式进行归约。通常可以省略1，写作SLR文法。
		\subsection{判定满足SLR文法输入串}
		根据SLR文法分析表，使用“文法符号栈-输入缓冲区-对应行为”三联表的形式，尝试读取并分析输入串，直到ACC或者ERR
	\section{规范的LR分析方法}
	在识别活前缀DFA的状态中，增加信息，可以排除一些不正确的归约操作，故规范的LR分析方法增加了前向搜索符：一个项目$A\to\alpha\cdot\beta$，如果真的用这个产生式进行规约之后，期望看到的符号是a（换句话说，在自底向上分析的过程中，对产生式右部$\alpha\beta$进行规约为$A$之后，在$A$的右边应当出现的符号）。LR(1)项目是一个二元组（SLR中的项，搜索符），形式的定义为$[A\to\alpha\cdot\beta,a]$。当$\beta$不为空的时候，a不起作用，当$\beta$为空的时候，如果下一个输入符号为a，那么将按照$A\to\alpha$进行规约，故有$a$的集合是FOLLOW(A)的子集。\par
	\begin{definition}
		对活前缀有效\par
		称LR(1)项目$[A\to\alpha\cdot\beta,a]$对活前缀$\gamma$有效，当且仅当如下情形：如果存在着推导$S'\Rightarrow^*_{rm}\delta Aw\Rightarrow_{rm}\delta\alpha\beta w$，其中$\gamma=\delta\alpha$，a是w的第一个符号，或者a是\$且w是$\varepsilon$
	\end{definition}
		\subsection{构造LR(1)项目集规范族}
		先声明一个我自己瞎起的名字：产生式左边的叫\textit{左值}，右边的都叫\textit{右值}。构造方法和SLR的构造方法类似：
		\begin{enumerate}
			\item 不妨设拓广文法的新开始产生式为$S'\to S$，那么从$S'\to\cdot S,\$$开始
			\item 【扩充闭包】在一个状态（项目集）中，对他现有的每一个项目$[A\to\alpha\cdot B\beta,a]$，进行如下构造：
			\begin{enumerate}
				\item 【左值】考虑点后面的非终结符B
				\item 【右值】对于拓展文法中的所有B在左边的产生式$B\to\gamma$（和SLR考虑的一样）
				\item 【搜索符】考虑$FIRST(\beta a)$中的每一个终结符b，并将$[B\to\cdots\gamma,b]$不重复地加入到状态集合中
			\end{enumerate}
			\item 【找全状态】规则和SLR一样，只是要注意，不仅点的位置不同就不同，搜索符不同也不同
		\end{enumerate}
		回顾一下FIRST集合的确定
		\begin{figure}[h!]
			\centering
			\begin{minipage}{20em}
				\centering
				\includegraphics[scale = 0.2]{images/LL1_first.pdf}
				\caption{确定给定推导文法的FIRST集合}
			\end{minipage}
			\begin{minipage}{20em}
				\centering
				\includegraphics[scale = 0.2]{images/LL1_follow.pdf}
				\caption{确定给定推导文法的FOLLOW集合}
			\end{minipage}
		\end{figure}
		\subsection{构造规范的LR分析表}
		表格形式与SLR类似，但是规则稍有变动：
		\begin{enumerate}
			\item 当点在右值中间时（$[A\to\alpha\cdot a\beta,b]$），根据$I_i\stackrel{a}{\to}I_j$，将$s_j$填入i行a列。\textit{注意这种情况下，搜索符b是没有用的。}在这种产生式的形式下，b的唯一用处是在求闭包的时候，求$FIRST(\beta a)$
			\item 当点在右值最右端时，\textbf{不再看FOLLOW(A)}，而是对于$I_i$中的所有$[A\to\alpha\cdot,a]$，将$r_j$（j为产生式编号）填入i行a列（其实就是看了FOLLOW的一个子集）
			\item acc和goto不变
		\end{enumerate}
		\subsection{LALR}
		就是在规范LR的基础上合并同心项目集（$i.e.$略去搜索符之后他们是相同的集合）。并按照规范LR的规则构造LALR分析表。合并同心项目集可能会引起冲突，但不会引起新的移进-归约冲突

	\chapter{语法制导的翻译}
	这一章开始赋予抽象的符号系统以实际的含义，进入到生成中间代码的阶段。\par
	语法和文法就像数理逻辑中的(语法)和(语义)，编译原理的语法是对前面文法分析树在具体程序语言（前提集）上的“赋值”，使得终结符和非终结符有了自己的“属性”。做一组不是很恰当的类比：语法=语法，语义规则=赋值，串=逻辑式，翻译=逻辑式的真假，文法符号=个体变元，属性=指派
	\section{语法制导的定义}
	语法制导（SDD）的定义是带属性和语义规则的上下文无关文法。SDD为CFG中的文法符号设置语义属性，用来表示语法成分对应的语义信息。语法制导翻译是使用上下文无关文法(CFG)来引导对语言的翻译，是一种面向文法的翻译技术。
	\paragraph{如何表示语法信息} 为CFG中的文法符号设置语义属性，用来表示语法成分对应的语义信息
	\paragraph{如何计算语义属性} 文法符号的语义属性值是用与文法符号所在产生式（语法规则）相关联的语义规则来计算的：对于给定的输入串x，构建x的语法分析树，并利用与产生式相关联的语义规则来计算分析树中各结点对应的语义属性值\par
	在语法制导中，用的是基础的上下文无关文法，每一个文法符号有一组属性，每一个文法产生式$A\to\alpha$有一组形式如$b=f(c_1,c_2,\cdots,c_k)$的语义规则，不一定这个产生式中的每一个元素的（每一个）属性都需要写进去。如果b是左值的属性，$c_1,\cdots,c_k$是右值的属性或者左值的其他属性，那么就叫b为综合属性。\textbf{终结符只能有综合属性，属性值无需计算，由词法分析给定}
		\subsection{综合属性和继承属性}
		仅仅使用综合属性地语法制导定义称为S属性定义。但是不是所有情况都这么简单，这时候就会用到继承属性（比如在消除了左递归的文法里面）\par
		总的来说，综合属性将属性自底向上传，而继承属性自上而下传。而对于如下产生式
		\[\begin{gathered}
			T\to FT'\\
			T'\to *FT'_1
		\end{gathered}\]
		在计算T的综合属性$T.syn$时，由于乘法运算符和操作数都隐藏在了$T'$里面，而这个隐藏内容在后续产生式$T'\to*FT'_1$里面，那么就需要将F的属性保存于T'的继承属性里面，传递到下一个“计算周期”，得到结果之后再返回到上一级并传递给T。如下：
		\begin{table}[h!]
			\centering
			\begin{tabular}{cc}
				\toprule
				产生式&语义规则\\
				\midrule
				$T\to FT'$&$T'.inh=F.val,\ T.val=T'.syn$\\
				$T'\to*FT'_1$&$T'_1.inh=T'.inh\times F.val,\ T'.syn=T'_1.syn$\\
				\bottomrule
			\end{tabular}
		\end{table}
		\subsection{注释分析树和属性依赖图}
		根据语法分析，构建出来语法分析树，然后在每一个节点根据其属性值进行计算。当这些属性都是综合属性时，计算可以自底向上地完成。\par
		如果分析树上的一个节点的属性b依赖于某个节点的属性c，那么b的语义规则的计算必须在c之后。这种依赖关系可以用一种称为\textbf{依赖图}的有向图来描述。
		\paragraph{虚拟属性}
		在构造分析树的依赖图之前，先为由过程调用组成的语义规则引入虚拟综合属性$b$，使得每一条规则都能写成$b=f(c_1,c_2,\cdots,c_k)$的形式。在语义分析时，每一个产生式都有一个综合属性（至少在向上返回的时候会用到的）。在后续推理过程中，逐渐（按需）加入继承属性。\par
		属性依赖图的组成是：分析树上的每个结点的每一个属性，都在依赖图上构造一个结点，如果属性b依赖于属性c，那么从c到b连一条有向边。
		\begin{enumerate}
			\item 属性值为点(vertex)：分析树中每个标号为X的结点的每个属性a都对应着依赖图中的一个结点
			\item 属性依赖关系为边(edge)：如果属性X.a的值依赖于属性Y.b的值，则依赖图中有一条从Y.b的结点指向X.a的结点的有向边
		\end{enumerate}
		\paragraph{属性计算次序}
		由语法制导定义规范的翻译可以准确地按照以下步骤（分析树方法）完成：
		\begin{enumerate}
			\item 根据基础文法构造输入的分析树
			\item 构造属性依赖图
			\item 对依赖图进行拓扑排序，得到语义规则对计算次序
			\item 按这个次序计算属性得到输入串的翻译
		\end{enumerate}
		属性计算依赖于拓扑排序，那么在有向图中，什么时候拓扑排序不存在呢：{\color[HTML]{FF7F50}\circled{1}当图中出现环的时候 \circled{2}SDD的属性之间存在循环依赖关系}（有互锁？）\par
		解决方案：使用某些特定类型的 依赖图不存在环的SDD：S属性的SDD和L属性的SDD\par
		一个没有副作用的SDD称为属性文法
		\begin{enumerate}
			\item 属性文法增加了语义规则描述的复杂度
			\item 如:符号表必须作为属性传递
			\item 为了简单起见，我们可以把符号表作为全局变量， 通过副作用函数读取或者添加标识符
		\end{enumerate}
		\subsection{具有受控副作用的语义规则}
		在实践中，翻译过程会出现一些副作用（什么是副作用呢？就是当一个操作/函数除了产生其计算结果外，还对其他部分产生了影响：一个桌上计算器可能打印出一个结果；一个代码生成器可能把一个标识符的类型加入到符号表中）。对于SDD，我们在属性文法和翻译方案之间找到一个平衡点。（why？）属性文法\footnote{一个没有副作用的SDD有时也称为属性文法（attribute grammar）。一个属性文法的规则仅仅痛哟其他属性值和常量值来定义一个属性值。（龙书P184，line 7）}没有副作用，并支持任何与依赖图一致的求值顺序。翻译方案(\ref{section:SDT})要求按从左到右的顺序求值，并允许语义动作包含任何程序片段。\par
		我们将按照下面的方法之一来控制SDD中的副作用：
		\begin{enumerate}
			\item 支持那些不会对属性求值产生约束的附带副作用，换句话说，如果按照依赖图的任何拓扑顺序进行属性求值时都可以产生“正确的”翻译结果，我们就允许副作用存在。这里的“正确”要视具体应用而定。
			\item 对允许的求值顺序添加约束，使得以任何允许的求值顺序都会产生相同的翻译结果，这些约束可以被看作隐含加入到依赖图中的边
		\end{enumerate}
	\section{语法制导的翻译方案}\label{section:SDT}
	语法制导翻译方案（syntax-directed translation scheme，SDT）是语法制导定义（syntax-directed definition，SDD）的一种补充。所有语法制导定义的应用都可以使用语法制导的翻译方案来实现。语法制导的翻译方案是在产生式右部中嵌入了程式片段（称为语义动作，它们可以出现在产生式体的的任何地方）的上下文无关文法（CFG）\par
	SDT可以看作是SDD的具体实现方案。任何SDT都可以通过下面的方法实现：首先建立一棵语法分析树，然后按照从左到右u的深度优先顺序来执行这些动作（前序遍历）。不过，通常情况下，SDT是在\textbf{语法分析}中实现的，而不会真的构造一棵语法分析树。那么下面就是如何使用SDT来实现两个重要的SDD，i.e：
	\begin{enumerate}
		\item 基本文法可以使用LR技术分析，且SDD是S属性的（仅仅用综合属性的SDD称为S属性的SDD）
		\item 基本文法可以使用LL技术分析，且SDD是L属性的（在一个产生式所关联的各属性之间，依赖图的边可以从左到右，但不能从右到左(因此称为L属性的，L是Left的首字母)）
	\end{enumerate}
	语法制导的翻译方案和语法制导定义不同之处是他的语义动作（在此不叫语义规则）放在花括号内，并且可以插入到产生式右部的\textbf{任何地方}，即这种表示法动作与分析交错。若$A\to\alpha\{\cdots\}\beta$，那么花括号中语义动作的执行要在$\alpha$的推导结束之后，在$\beta$的推导开始之前。下面是有关继承属性的几个限制：
	\begin{enumerate}
		\item 产生式右部符号的继承属性必须在先于这个符号的动作中计算
		\item 一个动作不能引用该动作右边符号的综合属性
		\item 左值的综合属性要放在右部的末端
		\item 多个继承属性，要考虑次序，避免形成环
	\end{enumerate}
	\section{S属性定义的自下而上计算}
	仅仅使用综合属性的语法制导定义称为S属性的SDD，或S-属性定义、S-SDD。
		\subsection{语法树}
		抽象语法树（简称语法树）是分析树的浓缩表示。在语法树中，算符（非终结符）和关键字（终结符）不是作为叶结点，而是作为分支结点。语法树上的内部结点都代表运算，其子节点都是他的运算对象。如同在分析树中那样，在语法树中也可以把属性附加到结点。\par
		语法树的结点可以用有若干指针域的记录来实现。对于算符结点，一个域放运算符，作为结点对象的标记，其余两个域存放只想运算对象的指针。对于基本运算对象结点，一个放\textbf{运算对象类型}，一个放他的值。在真正用于翻译时，语法树的结点可能还有其他域来保存其他属性值，或者属性值的指针（比如说，对于产生式$S\to\mathbf{if}\ B\ \mathbf{then}\ S_1\ \mathbf{else}\ S_2$，运算符\textbf{if-then-else}就有4个域（自己和三个运算对象）
		\subsection{S属性的SDD}
		每个属性都是综合属性。在依赖图中，总是通过子结点的属性值来计算父结点的属性值。\par
		语法制导定义SDD是对CFG的推广 \circled{1} 将每个文法符号和一个语义属性集合相关联 \circled{2} 将每个产生式和一组语义规则相关联，用来计算该产生式中各文法符号的属性值
		\subsubsection{将一个S属性的SDD转换为SDT}
		将每个语义动作都放在产生式的最后，并且在按照这个产生式体归约为产生式头的时候执行这个动作。所有动作都在产生式最右端的SDT称为“后缀翻译方案”。可以通过 \circled{1} 基于分析树的语法制导翻译方案 \circled{2} 语法分析栈 来实现。
		\begin{figure}[h]
			\centering
			\begin{minipage}{40em}
				\centering
				\includegraphics[scale = 0.4]{images/S_SDT_Implementation.pdf}
				\caption{基于分析树的语法制导翻译方案}
			\end{minipage}
		\end{figure}
		\subsection{后缀SDT的语法分析栈实现}
		后缀SDT可以在LR语法分析的过程中实现，当归约发生时执行相应的语义动作。各个文法符号的属性值可以放到栈中的某个位置。S属性定义的翻译器可以借助LR分析器的生成器来实现，LR可以把文法符号的综合属性放入栈内。\par
		如果所有属性都是综合属性，并且所有动作都位于产生式的末端，那么我们可以在把产生式体归约成产生式头的时候计算各个属性的值（why？这个时候产生式体中的所有符号都已经位于符号表中了——想一想综合属性的定义）。如果我们使用$A\to XYZ$这样的产生式进行归约，那么此时X、Y和Z的所有属性都是可用的，并且都位于已知的位置上（栈顶）。在这个动作之后，A和他的属性都位于栈的顶端，即现在存放X的记录的位置上。\par
		这又引出了另一种语义动作的表示方法，即用栈中相对于栈顶的位置来表示各个属性。如下面的SDT语句：
		\[A\to XYZ\{A.val=f(X.val,Y.val,Z.val)\}\]
		在$state$和$val$栈上可以转变为如下操作：
		\[\begin{cases}
			state[top-2]=A\\
			val[top-2]=f(val[top],val[top-1],val[top-2])\\
			top=top-2
		\end{cases}\]
		扩展LR的语法分析栈：
		\begin{enumerate}
			\item 在分析栈中使用一个附加的域来存放综合属性值。若支持多个属性，那么可以在栈中存放指针
			\item 每一个栈元素包含状态、文法符号、综合属性三个域。也可以将分析栈看成三个平行的栈，分别是状态栈、文法符号栈、综合属性栈，分开看的理由是，入栈出栈并不完全同步（即有些时候会有某一项不变的情况）
			\item 语义动作将修改为对栈中文法符号属性的计算
		\end{enumerate}\par
		栈操作代码：分为对照的两部分，产生式和代码段。和之前的代码段（对综合属性的赋值及运算）不同，这里由于将正在被分析的结点（们）的属性都入栈了（还维护了一个top指针），现在将这些属性用他们在栈中的位置来表达。注意在这个自底向上的分析中，每一行栈的排布是：产生式“右值”从右向左依次从栈顶向下排，在执行这一步的归约之后pop出去所有的右值，并将左值入栈。\par
		总的来说，采用自底向上分析，例如LR分析，首先给出 S-属性定义，然后，把S-属性定义变成可执行的代码段，放到产生式尾部，这就构成了翻译程序。（注：看一下紫书P118-119的表4.5，前三栏分别为状态栈、文法符号栈、综合属性栈）。随着语法分析的进行，归约前调用相应的语 义子程序，完成翻译的任务。
	\section{L属性定义的自上而下计算}
	\textit{显然，S属性定义属于L属性定义。}\par
	边分析边翻译的方式能否用于继承属性?
	\begin{itemize}
		\item 属性的计算次序一定受分析方法所限定的分析树 结点建立次序的限制
		\item 分析树的结点是自左向右生成
		\item 如果属性信息是自左向右流动，那么就有可能在分析的同时完成属性计算
	\end{itemize}\par
	可以在语法分析过程中实现的SDT包括后缀SDT和后面的一种“实现了L属性定义的”SDT。不是所有的SDT都可以在语法分析过程中实现（详见龙书P197的例子）
		\subsection{产生式内部带有语义动作的SDT}
		动作可以放置在产生式体中的任何位置上。当一个动作左边当所有符号都被处理过后，该动作立刻执行。因此，如果我们有一个产生式$B\to X\{a\}Y$，那么当我们识别到X（如果X是终结符）或者所有从X推导出当终结符号之后，动作a就会立即执行。更准确地讲，
		\begin{itemize}
			\item 如果语法分析过程是\textbf{自底向上}的，那么我们在X的此次出现位于语法分析栈的栈顶时，立刻执行动作a。\textit{从栈操作的过程上来看，这时恰好刚刚执行完{\myCoral 产生式头}为X的产生式的归约，故此时根据本节的定义，执行动作a的条件已经完备}
			\item 如果语法分析过程是自顶向下的，那么我们在试图展开Y的本次出现（如果Y是非终结符）或者在输入（输入符号表）中检测Y（如果Y是终结符）之前执行语义动作a。\textit{试想为何会将动作a放在这个位置？其实联想继承属性的求值方法不难看出，只有执行了这里的动作（如计算一个X的继承属性）才能在拆分Y的时候获得所有需要的值。想一下语法树和M点。}
		\end{itemize}
		\subsection{从SDT中消除左递归}
		前面语法分析的时候（\ref{subsection:Eliminating_Left_Recursion} 节）有对消除左递归的描述。当文法是SDT的一部分时，我们还需要考虑如何处理其中的动作。\par
			\paragraph{情况1：语句无赋值影响}
			先考虑简单的情况，即\textit{只需要关心一个SDT中的动作的执行顺序}的情况（如每个动作只打印一个字符串）。在这种情况下，可以应用下面这个原则完成这个转化：
			\begin{itemize}
				\item 当转换文法时，将动作当成终结符号处理
			\end{itemize}\par
			这个原则基于下面的思想：文法转换保持了由文法生成的符号串中终结符号的顺序（因为打印只有副作用而对各个符号对赋值没有任何影响）。因此，这些动作在任何从左到右对语法分析中都按照相同的顺序执行，不管这个分析是自顶向下还是自底向上的。
			\paragraph{情况2：动作是计算属性的值}
			好消息：如果这个SDD是是属性的，那么我们总是可以通过将计算属性值的动作放在新产生式中的适当位置来构造一个SDT（想一下前一个小节‘S属性的自下而上计算’中的处理）。\par
			下面是一个通用的解决方案，以解决只有单个递归产生式、单个非递归产生式并且该左递归非终结符号只有单个属性的情况（这么描述十分抽象，事实上可以看下面这个例子）。将这个方案推广到多个递归/非递归产生式的情况并不困难，但是写起来非常麻烦。假设这两个（S属性的）产生式是：
			\[\begin{gathered}
				A\to A_1Y\{A.a=g(A_1.a,Y.y)\}\\
				A\to X\{A.a=f(X.x)\}
			\end{gathered}\]\par
			基础文法会被改写成：
			\[\begin{gathered}
				A\to XR\\
				R\to YR\mid\varepsilon
			\end{gathered}\]\par
			为了完成这个翻译，我们使用如下SDT：（对于R，使用一个继承属性$R.i$来累计从$A.a$的值开始不断应用g所得的结果
			\[\begin{aligned}
				&A\to X\{R.i=f(X.x)\}R\{A.a=R.s\}\\
				&R\to Y\{R_1.i=g(R.i,Y.y)\}R_1\{R.s=R_1.s\}\\
				&R\to\varepsilon\{R.s=R.i\}
			\end{aligned}\]
			注意到这里还有一个综合属性$R.s$。当R不再生成文法符号Y时才开始计算这个属性的值，这个时间点时以产生式$R\to\varepsilon$的使用为标志的
	\section{L属性定义的SDT}
	很多翻译应用可以用L属性来解决，{\color[HTML]{FF0000}下面的方法通过遍历语法分析树来完成翻译工作（重要！）}
	\begin{enumerate}
		\item \textit{建立语法分析树并注释}。这个方法对任何非循环定义的SDD都有效
		\item \textit{构造语法分析树，加入动作，并按照前序遍历顺序来执行这些动作。}可以处理任何L属性定义，下面的第一节讨论了如何把一个L属性SDD转变为SDT，还特别讨论了\textbf{如何根据这样的SDD的语义规则把语义动作嵌入到产生式中}
		\item \textit{使用一个递归下降的语法分析器。}他为每个终结符都建立了一个函数。对应对非终结符A对函数以参数的方式接受A的继承属性，并返回A的综合属性
		\item \textit{使用一个递归下降的语法分析器，以边扫描边分析的方式生成代码}
		\item \textit{与LL语法分析器结合，实现一个SDT。}属性的值存放在语法分析栈中，而各个规则从栈中的已知位置获取需要的属性值。
		\item \textit{与LR语法分析器结合，实现一个SDT}。这个方法会让人觉得惊讶，因为一个L属性SDD的SDT通常有一些动作位于产生式中间，而在一个LR语法分析过程中，我们只有在构造出一个产生式体的全部符号之后才能肯定确实可以使用这个产生式。然而，\textbf{如果基础文法是LL的，总是可以按照自底向上的方式来处理语法分析和翻译过程}
	\end{enumerate}
	对于L属性的计算，考虑结合SDT，在语法分析过程中进行翻译
	\begin{enumerate}
		\item 自顶向下计算
		\begin{enumerate}
			\item 递归下降分析器
			\item LL分析器
		\end{enumerate}
		\item 自底向上计算，考虑与LR分析器的结合
		\begin{enumerate}
			\item 删除翻译方案中嵌入的动作
			\item 继承属性在分析栈中的计算
		\end{enumerate}
	\end{enumerate}
		\subsection{将L属性的SDD转换为SDT}\label{subsection:L_SDD_to_SDT}
		假设基础文法以自顶向下的方法进行语法分析，因为如果不是这样，那么翻译过程常常无法和一个LL或LR语法分析器一起完成。对于任何文法，我们\textbf{只需要将动作附加到一棵语法分析树中}，并在对这棵树进行前序遍历时执行这些动作，便可以实现下面的技术。将一个L属性的SDD转换为一个SDT的规则如下：
		\begin{enumerate}
			\item 把计算一个产生式左部符号的综合属性的动作放置在这个产生式右部的最右端
			\item 将计算某个非终结符号A的继承属性的动作插入到产生式右部中紧靠在A的本次出现之前的位置上（多个继承属性，要考虑次序，防止形成环）
		\end{enumerate}
		\subsection{在递归下降语法分析过程中进行翻译}
		在 \ref{subsection:Recursive_Descent} 节中提到，一个递归下降的语法分析器对每个非终结符号A都有一个函数A（伪代码描述见 \ref{section:Recursive_Descent_Function} 节）。我们可以按照如下方法把这个语法分析器扩展为一个翻译器：
		\begin{enumerate}
			\item 为每个非终结符A构造一个函数
			\begin{enumerate}
				\item A的每个继承属性对应该函数的一个形参
				\item 函数的返回值是A的综合属性值
			\end{enumerate}
			\item 在函数体中，要进行语法分析并处理属性
			\begin{enumerate}
				\item 首先选择适当的A的产生式
				\item 用局部变量保存产生式中文法符号的属性
				\item 对产生式体中的终结符号，读入符号并获取其综合属性(由词法分析得到)
				\item 对产生式体中的非终结符，调用相应函数，记录返回值
			\end{enumerate}
		\end{enumerate}
		\subsection{边扫描边生成代码}
		\subsection{L属性的SDD和LL语法分析}
		{\color[HTML]{ff0000}需要重新看录课，正确性未知。在龙书5.5.3，page 208}\par
		需要对分析栈进行扩充：增加动作记录action、增加属性记录\par
		假设一个L属性SDD是一个LL文法，并且已经按照前面所述的方法转换为一个SDT，其语义动作被嵌入到各个产生式中。然后，就可以在LL语法分析过程中完成翻译过程，\textbf{其中的语法分析栈需要扩展，以存放语义动作和属性求值所需的某些数据项}。一般来说，这些数据项是属性值的复制\par
		\textit{这里注意一个细节：SDD叫语法制导定义，SDT叫语法制导翻译\textbf{方案}，而现在我们做的是语法制导翻译这个过程}\par
		除了那些代表终结符和非终结符的记录之外，语法分析栈中还将保存\textit{动作记录}和\textit{综合记录}，其中动作记录表示即将被执行的动作，而综合记录保存非终结符号的综合属性值。使用下列两个原则来管理栈中的属性：
		\begin{enumerate}
			\item 非终结符A的继承属性放在表示这个非终结符号的栈记录中。对这些属性求值的代码通常使用紧靠在A的栈记录之上的动作记录来表示。实际上，从L属性的SDD到SDT的转换方法保证了动作记录将紧靠在A的上面
			\item 非终结符A的综合属性放在一个单独的综合记录中，他在栈中紧靠在A的记录下面
		\end{enumerate}
		\subsection{L属性的SDD的自底向上语法分析}
		考虑与LR分析器的结合\par
		我们可以使用自底向上的方法来完成任何可以用自顶向下方式完成的翻译过程。更准确的说，给定一个以LL文法为基础属性的L属性SDD，可以修改这个文法，并在LR语法分析过程中计算这个新文法之上的SDD。这个“技巧”包括三个部分：
		\begin{enumerate}
			\item 以按照 \ref{subsection:L_SDD_to_SDT} 节中的方法构造得到的SDT为起点。这样的SDT在各个非终结符之前放置语义动作来计算他的继承属性，并且在产生式后端放置一个动作来计算综合属性
			\item 对每个内嵌的语义动作，向这个文法中引入一个\textit{标记非终结符}来替换他。每个这样的位置都有一个不同的标记，并且对于任意一个标记M都有一个产生式$M\to\varepsilon$
			\item 如果标记非终结符M在某个产生式$A\to\alpha\{a\}\beta$中替换了语义动作a，对a进行修改得到$a'$，并且将a'关联到$M\to\varepsilon$上。这个动作a'
			\begin{enumerate}
				\item 将动作a需要的A或者$\alpha$中符号的任何属性作为M的继承属性进行复制
				\item 按照a中的方法计算各个属性，但是将计算得到的这些属性作为M的综合属性
			\end{enumerate}
		\end{enumerate}
		\paragraph{为什么标记能正确工作？}
		标记是只能推导出$\varepsilon$的非终结符，每个标记在所有产生式体中只出现一次。下面正式证明如果一个文法是LL的，那么标记非终结符号可以被插入到产生式体中的任何位置，并且结果文法是LR的。\par
		事实上，如果文法是LL的，那么只需要看输入符号串w的FIRST符号（如果w为空则是FOLLOW符号），就可以确定w是否可以从A开始，经过一个以产生式$A\to\alpha$开头的推导序列得到。因此，如果我们用自底向上的方式对w进行语法分析，那么只要w的开头出现在输入中，就可以确定w的一个前缀必须被归约成为$\alpha$，然后再归约到S。特别是，如果在$\alpha$的任何位置插入标记，相应的LR状态将隐含的表明这个标记必定存在，并将在输入的正确位置上把$\varepsilon$归约为标记

	\chapter{中间代码生成}
	中间表示设计的选择随编译器不同而不同。中间表示可以是一种实际的语言，也可以是编译各阶段共享的内部数据结构。C是一种编程语言，但它经常被当作一种中间形式，这是因为它灵活，能生成高效的机器代码，并且他的编译器到处可用。\par
	\textit{本章按照龙书编排，因为我不太喜欢PPT和紫书的顺序orz}
	\section{中间语言}
		\paragraph{后缀表示}
		波兰式、逆波兰式……
		\paragraph{图形表示（有向无环图，即DAG）}
		\subsection{三地址代码}\label{paragraph:triple_code}
		三地址代码是语法树或者DAG的一种线性表示，其中新增加的临时名字对应图的内部结点。
		\paragraph{静态单赋值形式，SSA}
	\section[]{表达式的翻译\footnote{龙书6.4节}}
		本节介绍在翻译表达式和语句时出现的问题。在本节中，先考虑从表达式到三地址代码（\ref{paragraph:triple_code}）的翻译。一个带有多个运算符的表达式（比如$a+b*c$将被翻译成为每条指令最多包含一个运算符的指令序列。类似的，一个数组引用$A[i][j]$将被扩展为一个计算该引用的地址的三地址指令序列。我们将在下一章考虑表达式的类型检查。
		\subsection{符号表中的名字}
			在介绍中间语言时，为了直观起见，让名字本身直接出现在三地址代码中，实际上应该把名字理解为他们在符号表中位置的指针。编译器在处理表达式、赋值语句等构造中的名字时，需要在符号表中查找它的定义，获得他的属性，然后在生成的三地址代码中使用它在符号表中位置的指针。下面一个小节中的$top.get$函数即是此作用（略去了检查是否返回值为NIL的步骤）
		\subsection{表达式中的运算}
			\textbf{本章中表达式均用符号E表示。}\par
			下面的语法制导定义使用S的属性$code$以及表达式$E$的属性$addr$和$code$，为一个赋值语句S生成三地址代码。属性$S.code$和$E.code$分别表示S和E对应的三地址代码。属性$E.addr$则表示存放E的值的地址。回忆一下前面对于三地址代码的描述（\ref{paragraph:triple_code}），一个地址可以是变量名字、常量或者编译器产生的临时量。
			\begin{table}[h]
				\centering
				\caption{表达式的三地址代码}
				\begin{tabular}{cc}
					\toprule
					产生式&语义规则\\
					\midrule
					$S\to\mathbf{id\ =\ }E\mathbf{\ ;}$&$S.code = E.code\parallel gen(top.get(\mathbf{id}.lexeme)\ '='\ E.addr)$\\[5pt]
					$E\to E_1+E_2$&$E.addr = \mathbf{new}\ Temp()$\\
					&$E.code = E_1.code\parallel E_2.code\parallel gen(E.addr'='E_1.addr'+'E_2.addr)$\\[5pt]
					$\mid -E_1$&$E.addr = \mathbf{new}\ Temp()$\\
					&$E.code = E_1.code\parallel gen(E.addr'=''\mathbf{minus}'E_1.addr)$\\[5pt]
					$\mid(E_1)$&$E.addr = E_1.addr$\\
					&$E.code = E_1.code$\\[5pt]
					$\mid\mathbf{id}$&$E.addr = top.get(\mathbf{id}.lexeme)$\\
					&$E.code = ''$\\
					\bottomrule
				\end{tabular}
			\end{table}\par
			第一个表项（非终结符S）为一个完整的语法分析的语句，而非终结符E则是此语句中的表达式。其中二元运算以加法为例。\par
			令$top$表示当前的符号表。当函数$top.get$被应用于$\mathbf{id}$的这个实例的\textit{字符串表示}$\textbf{id}.lexeme$时，它返回对应的符号表条目。\par
			$\mathbf{new}\ Temp()$指令会产生一个新的临时变量$t$，而连续执行这个指令会产生一系列互不相同的临时变量$t_1,t_2,\cdots$\par
			$gen$用于表达式和字符串的组合。为方便起见，使用记号$gen(x\ '='\ y\ '+'\ z)$来表示三地址指令$x=y+z$。当被传递给$gen$时，变量x、y、z的位置上出现的表达式将首先被求值，而像等号这样的引号内的字符串则按照字面值传递（在SDD中，gen构造一条指令并返回他，而在SDT中，gen构造出一条指令，并增量地将它添加到指令流中去）\par
			对$addr$属性的赋值可以看作是将这个非终结符的attributes填入符号表，而对这个属性的调用可以看作是对符号表的查找。S不具有这个$addr$的操作是因为不需要在其他（对表达式$code$进行处理的）地方用到S的值。\par
			除了对左式为S的产生式的SDD，在书写时都包含两部分，即对$E.addr$和对$E.code$的赋值。\par
			考虑上面的语法制导定义的最后一个产生式$E\to\mathbf{id}$。若表达式只是一个标识符，比如说x，那么$x$本身就保存了这个表达式本身的值。这个产生式对应的语义规则把$E.addr$定义为指向该\textbf{id}的实例对应的符号表条目的指针。$E.code$被设置为空串\par
			当翻译产生式$E\to E_1+E_2$时，首先将二者当$code$连接起来，然后再加上一条将$E_1$和$E_2$相加的指令（即gen语句）。新增加的这条指令将求和的结果放入一个为E生成的临时变量中，用$E.addr$表示。（为什么要这么处理呢？首先作为一个整体，非终结符E的任务就是计算$E_1$和$E_2$的和，所以一定需要添加那条gen语句。其次这个翻译过程可以看作是一个沿着语法分析树自底向上回溯的过程，生成的E的code里面应当包含底层的所有代码，这样才能在顶层也可以获取$E_1$和$E_2$的值。）
		\subsection{数组元素的寻址}
			如OS中所述，数组元素被存储在一块连续的空间中。对于k维数组，元素$A[i_1][i_2]\cdots[i_k]$的相对地址可用如下公式计算：
			\[base+i_1\times w_1+i_2\times w_2+\cdots+i_k\times w_k\]
			其中base时分配给数组A的内存块的相对地址，即$A[0]$的相对地址。而$w_i$是第i个维度的宽度。另一种表示方式是根据第j维上数组元素第个数$n_j$和该数组第每个元素第宽度$w=w_k$来计算的。如下：
			\[base+((\cdots((i_1\times n_2+i_2)\times n_3+i_3)\cdots)\times n_k+i_k)\times w_k\]
	\section{布尔表达式和控制流语句}
		在编程语言中，布尔表达式有两个基本目的，第一是用于计算逻辑值，第二而且更经常的是作为条件表达式，用于控制流语句，如if-then、if-then-else和while-do语句。\par
		if-else语句、while语句这类语句的翻译和对布尔表达式对翻译是结合在一起的。在程序设计语言中，布尔表达式经常用来：
		\begin{enumerate}
			\item \textit{改变控制流。}布尔表达式被用作语句中改变控制流的条件表达式。这些布尔表达式的值由程序到达的某个位置隐含地指出。例如，在$\textbf{if}(E)S$中，如果运行到语句S，就意味着表达式E的取值为真。
			\item \textit{计算逻辑值。}一个布尔表达式的值可以表达$true$或者$false$。这样的布尔表达式也可以像算术表达式一样，使用带有逻辑运算符的三地址指令进行求值
		\end{enumerate}
		\subsection{布尔表达式}
			下面是本节所用的布尔表达式文法：（relop是关系运算符，如$<,>,\le,\ge,==,!=$等）
			\[B\to B\ \mathbf{or}\ B\mid B\ \mathbf{and}\ B\mid\mathbf{not}\ B\mid(B)\mid E\ \mathbf{relop}\ E\mid\mathbf{true}\mid\mathbf{false}\]\par
			实现布尔表达式有两种方法：将真和假数值化，这样布尔表达式的计算就类似于算术表达式的运算（完全计算）；另一种方法就是借助控制流，即\textit{用程序中的位置来表示布尔表达式的值}，适用于短路计算的情况。
		\subsection{短路代码}
		在短路（跳转）代码中，布尔运算符$\&\&$、$||$和！被翻译成跳转指令。运算符本身不出现在代码中，布尔表达式的值是通过代码序列中的位置来表示的。\par
		短路运算是指，当通过逻辑运算符的左操作数就已经可以判断此表达式的值时，代码就不会再进入右边的代码块了。此称为短路运算。在短路运算中，上面三个布尔运算符所起到的逻辑作用在中间代码块中由转移语句 \texttt{goto} 来实现。\par
		例如语句
		\begin{quote}
			$if(x<100 || x>200 \&\& x!=y) x=0;$
		\end{quote}
		可以被翻译成如下所示的代码：
\begin{verbatim}
    if x < 100 goto L2
    ifFalse x > 100 goto L1
    ifFalse x != y goto L1
L1:	x = 0
L2:
\end{verbatim}
		在这个翻译中，如果程序的控制流到达L2，就表示这个表达式为真；如果表达式为假，则程序控制流将跳过L2块（包含了赋值语句），直接转到L1
	\section{控制流语句的翻译}
			将控制流语句翻译成其语义规则（SDT）分为两部分：对使用的各标签的定义；使用标签完成对产生式左值代码段的分段跳转式构造。这里对后者稍作解释：就像一个汇编文件一样，控制流语句会将代码进行分块处理，各个块之间会有跳转的逻辑联系。这些逻辑联系由继承属性$bb.next$或者强制跳转语句 \verb|goto| 来定义，而强制跳转语句将被显式地写入到对$S.code$的构造当中\par
			先来说两个龙书上面的简单控制流语句及其语义规则：
			\[P\to S\mbox{ 和 }S\to\mathbf{assign}\]
			前者的语义规则为
			\[\begin{gathered}
				S.next=newlabel()\\
				P.code = S.code\parallel label(S.next)
			\end{gathered}\]
			而后者的语义规则为
			\[S.code=\mathbf{assign}.code\]\par
			控制流语句（if-then、if-then-else、while-do、顺序执行）由下面的文法产生（B是布尔表达式）：
			\[\begin{aligned}
				S\to
				&\mathbf{if}\ B\ \mathbf{then}\ S_1\\
				&\mid\mathbf{if}\ B\ \mathbf{then}\ S_1\ \mathbf{else}\ S_2\\
				&\mid\mathbf{while}\ B\ \mathbf{do}\ S_1\\
				&\mid S_1;S_2
			\end{aligned}\]\par
			这四种语句对应的代码栈如下图所示，这几个图所示的三地址代码的结构可以帮助理解next的跳转。需要注意的是，$S.next$并没有被显式地画出来，而是作为（已知的）整个语句的出口，在后面的代码生成语法制导定义中被赋值给某些（语句块的）出口
			\begin{figure}[ht!]
				\centering
				\begin{minipage}{40em}
					\centering
					\includegraphics[scale = 0.4]{images/Bool_Expression_If_Code.png}
					\caption{if-then，if-then-else，while-do和顺序语句的代码（栈）}
				\end{minipage}
			\end{figure}
		\subsection{if语句中间代码生成的SDD}
			姑且命名语句$S\to\mathbf{if}\ B\ \mathbf{then}\ S_1$为产生式$\gamma$。\par
			这个“产生式”的每一个“非终结符”（$S,B,S_1$）都是一段代码，即他们的综合属性$S.code,\ etc$。每一个代码段都要有一个或多个“出口”，也就是说在执行结束这一段代码之后程序应当去往何方。这些“出口”用“非终结符”的继承属性来表示。可以调用$newlabel()$来产生新标号，新标号是跳转到这个产生式内部的时候，用（实际上是另一个非终结符的$.begin$的位置的）一个内部入口，而不是（将整个产生式封装起来看，放在“左值”的$.next$属性中的）一个总的出口，来对这个$.next$属性赋值。即：
			\begin{enumerate}
				\item 标号指向内部的三地址代码时需要调用$newlabel()$
				\item 标号指向外部的三地址代码时从$S$继承
			\end{enumerate}\par
			语义规则：
			\[\begin{gathered}
				B.true=newlabel()\\
				B.false=S.next\\
				S_1.next=S.next\\
				S.code=B.code\parallel gen(B.true,':')\parallel S_1.code
			\end{gathered}\]
		\subsection{带有else的语句的中间代码生成SDD}
			考虑带来else的语句$S\to\mathbf{if}\ B\ \mathbf{then}\ S_1\ \mathbf{else}\ S_2$。\par
			对布尔表达式B，用两个标号$B.true$和$B.false$分别表示B为真和为假时控制流应该转向的标号，这两个属性由B的上下文决定。注意在$S_1.code$的后面有$\mathrm{'goto'}\ ,S.next$，这条指令是需要的，因为$S_1$执行结束意味着$S$执行结束，并且当$S_1$是赋值语句的时候肯定会执行这条指令。\par
			（我觉得这块紫书说的不如龙书清楚…下面是龙书上的表述）由于布尔表达式中有一些向外跳转的指令，他们在B为真时跳转到$S_1$代码的第一条指令；B为假时跳转到$S_2$的代码的第一条指令。然后，控制流从$S_1$或者$S_2$跳转到紧跟在S的代码之后的三地址指令——该指令的标号由继承属性$S.next$指定。在$S_1$的代码之后有一条$goto\ S.next$指令，使得控制流越过$S_2$的代码。$S_2$的代码之后不需要$goto$语句，因为$S_2.next$就是$S.next$。语义规则如下：
			\[\begin{gathered}
				B.true = newlabel()\\
				B.false = newlabel()\\
				S_1.next = S.next\\
				S_2.next = S.next\\
				S.code = B.code\parallel label(B.true)\parallel S_1.code\parallel gen('goto'\ S.next)\parallel label(B.false)\parallel S_2.code
			\end{gathered}\]
		\subsection{while语句的中间代码生成SDD}
			while语句从逻辑上像是纯if语句的改版。while同样由$B.code$和$S_1.code$组成。由于循环的需要，在这个while语句的第一条指令上附加一个标号$begin$。与if-else中的处理类似，在$S_1$的末尾需要一条$goto$语句来重新回到$begin$（总之记住只要不是顺序执行的就要加goto去跳转。{\color[HTML]{FF0000}这块待议，为什么从$B.code$跳转到$B.false$就不需要加goto呢？}）。语义规则如下：
			\[\begin{gathered}
				begin = newlabel()\\
				B.true = newlabel()\\
				B.false = S.next\\
				S_1.next = begin\\
				S.code = label(begin)\parallel B.code\parallel label(B.true)\parallel S_1.code\parallel gen('goto'\ begin)
			\end{gathered}\]
		\subsection{顺序结构中间代码生成SDD}
			主要思想是“为每一语句$S_1$引入其后的下一条语句的标号”。语义规则如下：
			\[\begin{gathered}
				S_1.next = newlabel()\\
				S_2.next = S.next\\
				S.code = S_1.code\parallel label(S_1.next)\parallel S_2.code
			\end{gathered}\]
	\section{布尔表达式的控制流翻译}
		针对布尔表达式的语义规则是对于上一节中语句的语义规则的一个补充，$i.e.$上面的中间代码中的B部分即为这一节中要讨论的布尔表达式。一个布尔表达式B被翻译成\sout{一个}一组三地址指令，它将使用条件或无条件跳转指令来对B求值。这些跳转指令对目标是两个标号之一：当B为真时是$B.true$，反之$B.false$
		\paragraph{用控制流来实现计算}
			原则有两个： \circled{1} 布尔运算符and, or, not不出现在翻译后的代码中 \circled{2} 用程序中的位置来表示值
		\subsection{或运算}
			对于产生式$B\to B_1\parallel B_2$，我们现在用短路计算来进行考虑。如果$B_1$为真，那么我们立刻知道B本身也为真，而不需要再考虑$B_2$，因此$B_1.true$和$B.true$相同。如果$B_1$为假，那么需要对$B_2$求值，因此我们将$B_1.false$设置成$B_2$的代码的第一条指令的标号。这时相当于将表达式$B$的真假决定权交给了$B_2$，于是$B_2$的真假出口分别等于B的真假出口。语义规则如下：\
			\[\begin{gathered}
				B_1.true = B.true\\
				B_1.false = newlabel()\\
				B_2.true = B.true\\
				B_2.false = B.false\\
				B.code = B_1.code\parallel label(B_1.false)\parallel B_2.code
			\end{gathered}\]
		\subsection{且运算}
			产生式$B\to B_1\&\&B_2$的翻译方法类似与$B\to B_1\parallel B_2$。如果$B_1$为假，则B为假；反之考虑$B_2$的真值。其语义规则如下：
			\[\begin{gathered}
				B_1.ture = newlabel()\\
				B_1.false = B.false\\
				B_2.true = B.true\\
				B_2.false = B.false\\
				B.code = B_1.code\parallel label(B_1.true)\parallel B_2.code
			\end{gathered}\]
		\subsection{非运算}
			由于非运算仅有一个操作数，故不需要为$B\to!B_1$产生新的代码，只需要将B中的真假出口对换，就可以得到$B_1$的真假出口。由于没有短路运算，并不需要进行B内部的跳转，也不需要引入新的标记。其语义规则如下：
			\[\begin{gathered}
				B_1.true = B.false\\
				B_1.false = B.true\\
				B.code = B_1.code
			\end{gathered}\]
		\subsection{关系运算（relop）}
			产生式$B\to E_1\ \mathbf{relop}\ E_2$，其中E就是一个表达式，具有属性$addr$和$code$
	\section{回填}
		\begin{figure}[h]
			\centering
			\begin{minipage}{40em}
				\centering
				\includegraphics[scale = 0.4]{images/backpatching.pdf}
			\end{minipage}
			\caption{标号回填示例}
		\end{figure}
		为布尔表达式和控制流语句生成目标代码时，关键问题之一是将一个跳转指令和该指令的目标匹配起来。以表达式$\mathbf{if}(B)S$为例，在生成$goto\ B.false$时，并不知道跳过S应该跳到哪里（因为$S.code$还没有加进来呢）。在前面我们的处理方法是将标号作为继承属性传递到生成相关跳转指令的地方（就是上面的$B.false$）。但是，这样的做法要求再进行一遍处理，将标号和具体地址绑定起来。这两趟分析分别是生成语法树，和深度优先遍历树并计算属性值。\par
		回填用于解决布尔表达式短路计算翻译中，产生了转移目标不明确的条件或无条件代码的问题。解决方案是当生成跳转指令时，暂时不指定目标地址，当有关目标地址确定后，再填回到翻译代码中。在具体实现时，可以将有相同转移目标的转移代码的编号串起来形成链，可以方便回填目标地址。该list变成了综合属性，可以与LR结合（注：后面的翻译均是与LR结合的语法制导翻译方案）\par
		对于各层布尔表达式B，维护了两个综合属性：$B.truelist,B.falselist$。truelist是一个包含跳转或条件跳转指令的列表，向其中插入B为真时控制流应当转向的标号。在生成B的代码时，跳转到真或假出口的跳转指令时不完整的，标号字段尚未填写。这些不完整的跳转指令被保存在两个list中。\par
		具体过程是，首先在生成产生式左值code的过程（就是前面说的那个code的式子，添加指令和组合指令）中对各指令（code）进行标号，在这个过程中goto的标号暂时空着不填。然后在代码段的中间部分插入标记点。都写完之后回填标记点的标号。\par

	\chapter{类型检查}
		\textit{本节由龙书6.5节和紫书第五章构成。}\par
		静态的语义分析类型检查，利用逻辑规则分析运算分量的类型与运算符预期是否匹配。主要包括三个层次： \circled{1} 形式化描述类型结构（类型表达式） \circled{2} 判定两个类型相同的依据（类型等价：结构等价和名字等价） \circled{3} 定义一组逻辑规则检查语句或者表达式中是否存在逻辑错误（语法制导翻译方案实现、函数和算符的重载）
	\section{类型表达式}
		类型可以是语法的一部分，因此也是结构的。\par
		基本类型是类型表达式：integer、real、char、boolean、type\_error（出错类型，用于在类型检查中传递错误）、void（无类型，是语句的类型）。可以为类型表达式命名，类（class）名也是类型表达式。\par
		将类型构造算子作用域类型表达式可以得到新的类型表达式（如array，如果T是类型表达式，N是一个整数，则$array(N, T)$是类型表达式），（又如指针类型构造算子pointer，如果T是类型表达式，则$pointer(T)$是类型表达式），（再如笛卡尔乘积类型构造算子$\times$，如果T1和T2是类型表达式，则$T_1\times T_2$也是类型表达式。主要用于描述列表和元组，如表示函数的参数），（还有函数类型构造算子$\to$，若$T_1, T_2, \cdots, T_n$和$R$是类型表达式，则$T_1\times T_2 \times \cdots \times T_n \to R$也是），（以及记录类型构造算子record。若有标识符$N_1, N_2, \cdots, N_n$ 以及对应的类型表达式$T_1, T_2, \cdots, T_n$，则$record((N_1\times T_1)\times (N_2\times T_2) \times \cdots\times (N_n\times T_n) )$ 也是类型表达式\par
		\begin{figure}[h]
			\centering
			\begin{minipage}{40em}
				\centering
				\includegraphics[scale = 0.2]{images/struct_type.PNG}
			\end{minipage}
			\caption{记录类型构造算子}
		\end{figure}
		\subsection{自动生成类型表达式}
			即构造类型表达式的SDD。\par
			首先需要为每个文法符号设置综合属性t和继承属性b。其中t是该符号对应的类型表达式，而b的作用是将类型信息沿着语法树从左向右传递
		\subsection{构造类型表达式的SDT}
			语法制导翻译方案就是将对属性值的动作（code）嵌入到表达式中，见（\ref{section:SDT}）。不过在这个过程中会遇到一些问题，比如继承属性的计算就与LR分析不匹配，因此，如果使用LR，就需要改造文法。与前面对goto语句的处理类似，这里也采取了标号方法
	\section{类型等价}
		\paragraph{结构等价}
			如下规则： \circled{1} 两个类型表达式完全相同（当无类型名时）：类型表达式树一样，相同的类型构造符作用于相同的子表达式。 \circled{2} 当有类型名时，用他们所定义的类型表达式代换他们，所得的表达式完全相同（类型定义无环时）
		\paragraph{名等价}
			把每一个类型名看成一个可区别的类型，两个类型表达式名字等价当且仅当：他们是相同的基本类型、不进行名字代换就能结构等价\par
			C语言对除记录(结构体)以外的所有类型使用结构等价，而记录类型用的是名字等价，以避免类型图中的环。下面一个例子：
			\begin{figure}[h]
				\centering
				\begin{minipage}{40em}
					\centering
					\includegraphics[scale = 0.4]{images/type_equal.jpg}
				\end{minipage}
				\caption{结构体是名等价}
			\end{figure}
	\section{类型检查}

	\chapter{与类型相关的中间代码生成}
		\section{符号表}
			符号表的使用和修改贯穿了编译的全过程，它存储了各种信息，如变量名、函数名、对象、类、interface、类型信息、占用空间、作用域等。它用于编译过程中的分析与合成： \circled{1} 语义分析：如使用前声明检查、类型检查、确定作用域等 \circled{2} 合成：如类型表达式构造、内存空间分配等
		\section{声明语句的翻译}
			声明语句翻译的要点有：
			\begin{enumerate}
				\item 分配存储单元：名字、类型、字宽、偏移
				\item 作用域的管理：过程调用
				\item 记录类型的管理
				\item 不产生中间代码指令，但是要更新符号表
			\end{enumerate}
			如下例：$T\to integer\mid real\mid array[num]of\ T_1\mid \uparrow T_1$，T可以具有type（变量所具有的类型）、width（该类型数据所占的字节数）、offset（变量的存储偏移地址）
		\section{作用域的管理}
			管理作用域（过程嵌套声明）：每个过程内声明的符号要置于该过程的符号表中；方便地找到子过程和父过程对应的符号。\par
			符号表的特点及数据结构：
			\begin{enumerate}
				\item 各过程有各自的符号表:哈希表
				\item 符号表之间有双向链：父$\to$子:过程中包含哪些子过程定义；子$\to$父:分析完子过程后继续分析父过程
				\item 维护符号表栈(tblptr)和地址偏移量栈(offset)：保存尚未完成的过程的符号表指针和相对地址
			\end{enumerate}

\end{document}
